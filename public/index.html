<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dumb Drop - Simple File Upload</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <script src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
</head>
<body>
    <div class="container">
        <h1>Dumb Drop</h1>
        <div class="upload-container" id="dropZone">
            <div class="upload-content">
                <svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                <p>Drag and drop files here<br>or</p>
                <input type="file" id="fileInput" multiple hidden>
                <button onclick="document.getElementById('fileInput').click()">Browse Files</button>
            </div>
        </div>
        <div id="uploadProgress"></div>
        <div id="fileList" class="file-list"></div>
        <button id="uploadButton" class="upload-button" style="display: none;">Upload Files</button>
    </div>

    <script>
        const CHUNK_SIZE = 1024 * 1024; // 1MB chunks
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 1000;

        class FileUploader {
            constructor(file) {
                this.file = file;
                this.uploadId = null;
                this.position = 0;
                this.progressElement = null;
                this.retries = 0;
            }

            async start() {
                try {
                    await this.initUpload();
                    await this.uploadChunks();
                    return true;
                } catch (error) {
                    console.error('Upload failed:', error);
                    return false;
                }
            }

            async initUpload() {
                const response = await fetch('/upload/init', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: this.file.name,
                        fileSize: this.file.size
                    })
                });

                if (!response.ok) throw new Error('Failed to initialize upload');
                const data = await response.json();
                this.uploadId = data.uploadId;
            }

            async uploadChunks() {
                this.createProgressElement();

                while (this.position < this.file.size) {
                    const chunk = await this.readChunk();
                    try {
                        await this.uploadChunk(chunk);
                        this.retries = 0;
                    } catch (error) {
                        if (this.retries >= MAX_RETRIES) throw error;
                        this.retries++;
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                        continue;
                    }
                }
            }

            async readChunk() {
                const start = this.position;
                const end = Math.min(this.position + CHUNK_SIZE, this.file.size);
                const blob = this.file.slice(start, end);
                this.position = end;
                return blob;
            }

            async uploadChunk(chunk) {
                const response = await fetch(`/upload/chunk/${this.uploadId}`, {
                    method: 'POST',
                    body: chunk
                });

                if (!response.ok) throw new Error('Chunk upload failed');
                const data = await response.json();
                this.updateProgress(data.progress);
            }

            createProgressElement() {
                const container = document.createElement('div');
                container.className = 'progress-container';
                
                const label = document.createElement('div');
                label.className = 'progress-label';
                label.textContent = this.file.name;

                const progress = document.createElement('div');
                progress.className = 'progress';
                
                const bar = document.createElement('div');
                bar.className = 'progress-bar';
                bar.style.width = '0%';

                progress.appendChild(bar);
                container.appendChild(label);
                container.appendChild(progress);
                
                document.getElementById('uploadProgress').appendChild(container);
                this.progressElement = { container, bar };
            }

            updateProgress(percent) {
                if (this.progressElement) {
                    this.progressElement.bar.style.width = `${percent}%`;
                    if (percent === 100) {
                        setTimeout(() => {
                            this.progressElement.container.remove();
                        }, 1000);
                    }
                }
            }
        }

        // UI Event Handlers
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const uploadButton = document.getElementById('uploadButton');
        let files = [];

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        dropZone.addEventListener('drop', handleDrop, false);
        fileInput.addEventListener('change', handleFiles, false);
        uploadButton.addEventListener('click', startUploads);

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight(e) {
            dropZone.classList.add('highlight');
        }

        function unhighlight(e) {
            dropZone.classList.remove('highlight');
        }

        function handleDrop(e) {
            files = [...e.dataTransfer.files];
            updateFileList();
        }

        function handleFiles(e) {
            files = [...e.target.files];
            updateFileList();
        }

        function updateFileList() {
            fileList.innerHTML = '';
            files.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.textContent = `${file.name} (${formatFileSize(file.size)})`;
                fileList.appendChild(fileItem);
            });
            uploadButton.style.display = files.length > 0 ? 'block' : 'none';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        async function startUploads() {
            uploadButton.disabled = true;
            document.getElementById('uploadProgress').innerHTML = '';
            
            const results = await Promise.all(
                files.map(async file => {
                    const uploader = new FileUploader(file);
                    return await uploader.start();
                })
            );

            const successful = results.filter(r => r).length;
            
            Toastify({
                text: `Uploaded ${successful} of ${files.length} files`,
                duration: 3000,
                gravity: "bottom",
                position: "right",
                style: {
                    background: successful === files.length ? "#4CAF50" : "#f44336"
                }
            }).showToast();

            files = [];
            updateFileList();
            uploadButton.disabled = false;
        }
    </script>
</body>
</html>
